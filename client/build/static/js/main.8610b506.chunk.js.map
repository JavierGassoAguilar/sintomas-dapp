{"version":3,"sources":["getWeb3.js","App.js","serviceWorker.js","index.js"],"names":["getWeb3","Promise","resolve","reject","window","addEventListener","a","ethereum","web3","Web3","enable","console","log","provider","providers","HttpProvider","App","state","accounts","contract","textoSintoma","textoRemedio","tipoRemedioSeleccionado","ultimoSintomaId","sintomas","remedios","textoBuscador","componentDidMount","eth","getAccounts","net","getId","networkId","deployedNetwork","SintomasDappContract","networks","Contract","abi","address","setState","alert","error","registrarSintoma","sintoma","methods","tengoUnSintoma","send","from","response","obtenerSintomasDapp","call","i","resultado","length","split","includes","push","idSintoma","hintertarremedio","tengoRemedio","listarRemedios","ultimoRemedioId","idRemedio","tipoRemedio","remedio","remediador","sumaCalificacionRemedio","numeroVotosRemedio","valorarRemedio","temporal","prompt","valoroRemedio","parseInt","this","className","class","type","value","onChange","e","target","onClick","map","item","itemR","toFixed","Component","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.8610b506.chunk.js","sourcesContent":["import Web3 from \"web3\";\n\nconst getWeb3 = () =>\n  new Promise((resolve, reject) => {\n    // Wait for loading completion to avoid race conditions with web3 injection timing.\n    window.addEventListener(\"load\", async () => {\n      // Modern dapp browsers...\n      if (window.ethereum) {\n        const web3 = new Web3(window.ethereum);\n        try {\n          // Request account access if needed\n          await window.ethereum.enable();\n          // Acccounts now exposed\n          resolve(web3);\n        } catch (error) {\n          reject(error);\n        }\n      }\n      // Legacy dapp browsers...\n      else if (window.web3) {\n        // Use Mist/MetaMask's provider.\n        const web3 = window.web3;\n        console.log(\"Injected web3 detected.\");\n        resolve(web3);\n      }\n      // Fallback to localhost; use dev console port by default...\n      else {\n        const provider = new Web3.providers.HttpProvider(\n          \"http://127.0.0.1:8545\"\n        );\n        const web3 = new Web3(provider);\n        console.log(\"No web3 instance injected, using Local web3.\");\n        resolve(web3);\n      }\n    });\n  });\n\nexport default getWeb3;\n","import React, { Component } from \"react\";\r\nimport SintomasDappContract from \"./contracts/SintomasDapp.json\";\r\nimport getWeb3 from \"./getWeb3\";\r\n\r\nimport \"./App.css\";\r\n\r\nclass App extends Component {\r\n  state = { \r\n    web3: null, \r\n    accounts: null, \r\n    contract: null,\r\n    textoSintoma: '',\r\n    textoRemedio: '',\r\n    tipoRemedioSeleccionado: '',\r\n    ultimoSintomaId: 0,\r\n    sintomas: [],\r\n    remedios: [],\r\n    textoBuscador: '',\r\n  };\r\n\r\n  componentDidMount = async () => {\r\n    try {\r\n      const web3 = await getWeb3();\r\n      const accounts = await web3.eth.getAccounts();\r\n      const networkId = await web3.eth.net.getId();\r\n      const deployedNetwork = SintomasDappContract.networks[networkId];\r\n      const contract = new web3.eth.Contract(\r\n        SintomasDappContract.abi,\r\n        deployedNetwork && deployedNetwork.address,\r\n      );\r\n      this.setState({ \r\n        web3, \r\n        accounts, \r\n        contract\r\n      });\r\n    } catch (error) {\r\n      // Catch any errors for any of the above operations.\r\n      alert(\r\n        `Failed to load web3, accounts, or contract. Check console for details.`,\r\n      );\r\n      console.error(error);\r\n    }\r\n  };\r\n\r\n  registrarSintoma = async (sintoma) => {\r\n    const response = await this.state.contract.methods.tengoUnSintoma(sintoma).send({from: this.state.accounts[0]});\r\n    console.log(response);\r\n  };\r\n\r\n  obtenerSintomasDapp = async () => {\r\n    const ultimoSintomaId = await this.state.contract.methods.ultimoSintomaId().call();\r\n    this.setState({ ultimoSintomaId });\r\n    let sintomas = [];\r\n    for (let i = 1; i <= this.state.ultimoSintomaId; i++) {\r\n      const resultado = await this.state.contract.methods.sintomas(i).call();\r\n      // Palabra del buscador:   this.state.textoBuscador  \"espalda\"\r\n      // Texto del sintoma:      resultado.sintoma         \"dolor de espalda\"\r\n      if (this.state.textoBuscador.length === 0 || resultado.sintoma.split(' ').includes(this.state.textoBuscador)) {\r\n        sintomas.push({\r\n          idSintoma: resultado.idSintoma,\r\n          sintoma: resultado.sintoma,\r\n        });\r\n      }\r\n\r\n\r\n    }\r\n    this.setState({ sintomas });\r\n  };\r\n\r\n  hintertarremedio = async (sintoma) => {\r\n    const response = await this.state.contract.methods.tengoRemedio(sintoma, this.state.tipoRemedioSeleccionado, this.state.textoRemedio).send({from: this.state.accounts[0]});\r\n    console.log(response);\r\n  };\r\n\r\n  listarRemedios = async () => {\r\n    const ultimoRemedioId = await this.state.contract.methods.ultimoRemedioId().call();\r\n    let remedios = [];\r\n    for (let i = 1; i <= ultimoRemedioId; i++) {\r\n      const resultado = await this.state.contract.methods.remedios(i).call();\r\n      remedios.push({\r\n        idSintoma: resultado.idSintoma,\r\n        idRemedio: resultado.idRemedio,\r\n        tipoRemedio: resultado.tipoRemedio,\r\n        remedio: resultado.remedio,\r\n        remediador: resultado.remediador,\r\n        sumaCalificacionRemedio: resultado.sumaCalificacionRemedio,\r\n        numeroVotosRemedio: resultado.numeroVotosRemedio\r\n      })\r\n    }\r\n    this.setState({ remedios });\r\n\r\n  };\r\n\r\n  valorarRemedio = async idRemedio => {\r\n    const temporal = window.prompt('Valoracion (0-10)');\r\n    console.log(\"idRemedio\", idRemedio);\r\n    console.log(\"temporal\", temporal);\r\n    const response = await this.state.contract.methods.valoroRemedio(parseInt(idRemedio, 10), parseInt(temporal, 10)).send({from: this.state.accounts[0]});\r\n    console.log(response);\r\n  };\r\n\r\n  render() {\r\n    if (!this.state.web3) {\r\n      return <div>Loading Web3, accounts, and contract...</div>;\r\n    }\r\n    return (\r\n      <div className=\"App\">\r\n\r\n        <article class=\"message cajita\">\r\n          <div class=\"message-header\">\r\n            <p>Registrar síntoma</p>\r\n          </div>\r\n          <div class=\"message-body\">\r\n            <input \r\n              class=\"input is-warning separado-abajo\"\r\n              type=\"text\" \r\n              value={this.state.textoSintoma} \r\n              onChange={e => this.setState({ textoSintoma: e.target.value })} \r\n            />\r\n            <button class=\"button is-success\" onClick={() => this.registrarSintoma(this.state.textoSintoma)}>Registrar síntoma</button>\r\n          </div>\r\n        </article>\r\n\r\n        <article class=\"message cajita\">\r\n          <div class=\"message-header\">\r\n            <p>Lista de sintomas registrados</p>\r\n            <input \r\n              class=\"input is-small caja-buscador\" \r\n              type=\"text\"\r\n              value={this.state.textoBuscador}\r\n              onChange={e => this.setState({ textoBuscador: e.target.value })} \r\n            />\r\n            <button class=\"button is-success\" onClick={() => this.obtenerSintomasDapp()}>Buscar</button>\r\n          </div>\r\n          <div class=\"message-body\">\r\n\r\n            {this.state.sintomas.map(item =>\r\n              <div class=\"contenedor-sintoma\">\r\n                <p><strong>{item.sintoma}</strong> </p>\r\n                <br />\r\n                <select onChange={e => this.setState({ tipoRemedioSeleccionado: e.target.value })} value={this.state.tipoRemedioSeleccionado} class=\"select is-small caja-20\">\r\n                  <option>Tipo remedio</option>\r\n                  <option value=\"YOGA\">Posturas de Yoga</option>\r\n                  <option value=\"INFUSION\">Infusión</option>\r\n                  <option value=\"HOMEOPATIA\">Homeopatía</option>\r\n                  <option value=\"OTROS\">Otros</option>\r\n                </select>\r\n                <input \r\n                  class=\"input is-small remedio-input\"\r\n                  type=\"text\" \r\n                  value={this.state.textoRemedio} \r\n                  onChange={e => this.setState({ textoRemedio: e.target.value })} \r\n                />\r\n                <button class=\"button boton-sintoma is-small caja-20\" onClick={() => this.hintertarremedio(item.idSintoma)}>Insertar remedio</button>\r\n                <button class=\"button boton-sintoma is-small\" onClick={() => this.listarRemedios()}>Consultar remedios</button>\r\n\r\n\r\n                <table class=\"table\">\r\n                  <thead>\r\n                    <tr>\r\n                      <th>Tipo</th>\r\n                      <th>Descripcion</th>\r\n                      <th>Valoracion media</th>\r\n                      <th>Acciones</th>\r\n                    </tr>\r\n                  </thead>\r\n                  <tbody>\r\n                    {this.state.remedios.map(itemR => {\r\n                      if (itemR.idSintoma === item.idSintoma) {\r\n                        return <tr>\r\n                                  <td>{itemR.tipoRemedio}</td>\r\n                                  <td>{itemR.remedio}</td>\r\n                                  <td>{(itemR.sumaCalificacionRemedio/itemR.numeroVotosRemedio).toFixed(1)} ({itemR.numeroVotosRemedio} votos)</td>\r\n                                  <td><button class=\"button boton-sintoma is-small\" onClick={() => this.valorarRemedio(itemR.idRemedio)}>Valorar</button></td>\r\n                               </tr>  \r\n                      }\r\n                      }\r\n                    )}\r\n                  </tbody>\r\n              </table>\r\n\r\n              </div>\r\n            )}\r\n          </div>\r\n        </article>\r\n\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}